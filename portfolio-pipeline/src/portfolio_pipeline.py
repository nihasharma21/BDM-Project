# -*- coding: utf-8 -*-
"""v2 Final Group 3 Final working version.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p-LRSv33q_aEn5ZPdovto0qvTgHf3zMP

# Group 3 Stock Portfolio Risk vs Return Analysis

We created two functions:
1. Function 1 is to calculate the stock returns using the information provided by the user. The information required is : Stock Ticker List, Investment Start Date, Investement End Date .
2. Function 2 is then created to analyze the risk vs return analysis

Both the functions are called in the third cell code which will analyze the returns and then show risk vs return charts for selected stocks.

# Downloading Server and Importing modules
"""

# Commented out IPython magic to ensure Python compatibility.
#  #Download the server
# %%capture
# import sys
# import os
# 
# if 'google.colab' in sys.modules:
#   !pip install idaes-pse --pre
#   !idaes get-extensions --to ./bin
#   os.environ['PATH'] += ':bin'
# 
#   #importing modules
#   from pyomo.environ import *
#   import pandas as pd
#   import numpy as np
#   import matplotlib.pyplot as plt

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import yfinance as yf
from IPython.display import display

from pyomo.environ import (
    ConcreteModel,
    Set,
    Var,
    Param,
    NonNegativeReals,
    Objective,
    Constraint,
    maximize,
)
from pyomo.opt import SolverFactory, TerminationCondition


"""# Function 1: Fetching and Analyzing Stock Returns"""

def fetch_and_analyze_returns(startdate, enddate, ticker_list):
  # some useful modules
  import numpy as np
  import pandas as pd
  import matplotlib.pyplot as plt
  import seaborn as sns

  import yfinance as yf
  from IPython.display import display

  #tickers_list = ['NFLX', 'T', 'CMCSA', 'META', 'LYV', 'AAPL', 'ADBE', 'PLTR', 'CSCO', 'MSFT', 'EQIX','ESS','DLR','VTR','SBAC'] # Commenting as it should pick from the func calling

  start = startdate
  end    = enddate # today!

  dow_prices = {}
  for t in ticker_list:
      try:
          df = yf.download(t, start=start, end=end, interval="1d", progress=False, auto_adjust=False)
          if not df.empty:
              dow_prices[t] = df
          else:
              print(f"Warning: no data returned for {t}")
      except Exception as e:
          print(f"Failed {t}: {e}")

  # take a peak!
  # dow_prices # Commented out to prevent verbose output during execution

  prep_data = pd.DataFrame(dow_prices[ticker_list[0]]['Adj Close']).rename(columns = {"Adj Close":ticker_list[0]})

  # combine all the tickers (all the rest of the samples)
  for i in ticker_list[1:]:
    prep_data[i] = pd.DataFrame(dow_prices[i]['Adj Close'])
  # prep_data # Commented out to prevent verbose output during execution
  # prep_data.shape # Commented out to prevent verbose output during execution

  # create return features for each ticker,
  # we will just use a pct_change as the return
  return_data = pd.DataFrame()
  for i in ticker_list:
    return_data[i] = prep_data[i].pct_change()
  # drop the na records
  return_data.dropna(inplace=True)
  # return_data # Commented out to prevent verbose output during execution

  # Calculate cumulative returns for simple returns
  cumulative_returns = (1 + return_data).cumprod() - 1

  # Plot the cumulative returns
  cumulative_returns.plot(figsize=(15, 10))
  plt.title('Cumulative Percentage Returns Over Time')
  plt.xlabel('Date')
  plt.ylabel('Cumulative Return')
  plt.grid(True)
  plt.show()

  # Calculate log returns
  log_return_data = pd.DataFrame()
  for i in ticker_list:
    log_return_data[i] = np.log(prep_data[i] / prep_data[i].shift(1))

  # Drop the na records
  log_return_data.dropna(inplace=True)

  print("Simple Returns (using pct_change):")
  display(return_data.head())

  print("\nLog Returns:")
  display(log_return_data.head())

  # return_data.shape # Commented out to prevent verbose output during execution

  return_data.plot(subplots=True,
          grid=True,
          layout=(20,16),
          figsize=(15,15))
  plt.show()

  # Calculate monthly returns
  monthly_returns = prep_data.resample('ME').ffill().pct_change()

  # Drop the first row which will contain NaNs
  monthly_returns.dropna(inplace=True)

  print("Here are the Monthly Returns:")
  display(monthly_returns)

  monthly_returns[ticker_list[0]].plot() # Updated to use the first ticker from ticker_list

  monthly_returns.plot()

  monthly_returns.mean()

  monthly_returns.cov()

  # the covariance matrix
  cov_matrix = monthly_returns.cov()

  # Plot the covariance matrix as a heatmap
  plt.figure(figsize=(20, 16))
  sns.heatmap(cov_matrix, annot=True, cmap='coolwarm', fmt=".4f", center=0)
  plt.title('Covariance Matrix of Monthly Returns')
  plt.show()

  # Calculate the covariance matrix
  cor_matrix = monthly_returns.corr()

  # Plot the covariance matrix as a heatmap
  plt.figure(figsize=(20, 16))
  sns.heatmap(cor_matrix, annot=True, cmap='coolwarm', fmt=".4f", center=0)
  plt.title('Correlation Matrix of Monthly Returns')
  plt.show()

  # monthly_returns.shape # Commented out to prevent verbose output during execution

  print('Shape of monthly_returns:', monthly_returns.shape)
  return monthly_returns
  # print('Monthly returns above\n\n\n\n') # Commented out as it's unreachable after return

"""# Function 2: Run Portfolio Model

"""

def run_portfolio_model(df: 'pd.DataFrame', ipopt_executable: str = './bin/ipopt'):
  #Concrete Model
  print ('Lets define the concrete model\n\n')

  # Initialize model
  m = ConcreteModel()
  #print(df.head())

  #Decision Variable
  print("Lets define the decision variables now\n\n")
  # Load data
  import pandas as pd
  # df = df.set_index("Month")

  # Asset list
  assets = df.columns.tolist()
  m.Assets = Set(initialize=assets)

  # Define decision variables for each asset
  m.x = Var(m.Assets, within=NonNegativeReals, bounds=(0,1))

  # Covariance matrix (Sigma)
  cov_df = df.cov()
  cov_dict = {(i, j): cov_df.loc[i, j] for i in assets for j in assets}
  m.Sigma = Param(m.Assets, m.Assets, initialize=cov_dict)
  print("Checking the covariance values\n\n")
  m.pprint()

  #Objective Function
  # Calculate average returns per asset
  avg_returns = df.mean().to_dict()

  # Create a Pyomo Param from this
  m.mu = Param(m.Assets, initialize=avg_returns)

  # Objective: Maximize expected return
  def total_return(m):
      return sum(m.mu[a] * m.x[a] for a in m.Assets)

  m.objective = Objective(rule=total_return, sense=maximize)
  print("Printing the objective function equation\n\n")
  m.pprint()

  #Constraints
  print('Constraint 1: Sum to 1\n')
  def budget_constraint(m):
      return sum(m.x[a] for a in m.Assets) == 1

  m.budget = Constraint(rule=budget_constraint)

  print('Constraint 2: Must be non-zero \n\n')
  def dummy_total_risk_rule(m):
      return sum(m.x[a] for a in m.Assets) >= 0.0

  m.total_risk = Constraint(rule=dummy_total_risk_rule)

  print('Constraint 3: Sum weighted cov matrix \n\n')


  from pyomo.opt import SolverFactory, TerminationCondition

  # Risk thresholds to test
  max_risk = 0.1
  risk_limits = np.arange(0.005, max_risk, 0.001)

  # Result storage
  param_analysis = {}
  returns = {}

  # Define solver
  solver = SolverFactory("ipopt", executable=ipopt_executable)

  for r in risk_limits:
      # Remove old variance constraint if it exists
      if hasattr(m, 'variance_constraint'):
          m.del_component(m.variance_constraint)

      # Add new variance constraint for this risk level
      def variance_constraint_rule(m):
          return sum(m.Sigma[i, j] * m.x[i] * m.x[j] for i in m.Assets for j in m.Assets) <= r
      m.variance_constraint = Constraint(rule=variance_constraint_rule)

      # Solve
      result = solver.solve(m)

      # Skip infeasible solutions
      if result.solver.termination_condition == TerminationCondition.infeasible:
          continue

      # Save allocations and returns
      param_analysis[r] = [m.x[a]() for a in m.Assets]
      returns[r] = sum(m.mu[a] * m.x[a]() for a in m.Assets)


  # Create DataFrame for plotting
  df_results = pd.DataFrame({
      'Risk': list(returns.keys()),
      'Return': list(returns.values())
  })

  # Sort by Risk (just in case)
  df_results = df_results.sort_values(by='Risk')
  df_results.head(n=10)

  import matplotlib.pyplot as plt

  plt.figure(figsize=(10,6))
  plt.plot(df_results['Risk'], df_results['Return'], marker='o', linestyle='-')
  plt.title("Efficient Frontier")
  plt.xlabel("Portfolio Risk (Variance)")
  plt.ylabel("Expected Return")
  plt.grid(True)
  plt.show()

  import matplotlib.pyplot as plt
  import pandas as pd

  # Convert allocation results to DataFrame
  df_allocations = pd.DataFrame(param_analysis).T  # rows = risk, columns = assets
  df_allocations.columns = assets
  df_allocations['Risk'] = df_allocations.index

  # Plot allocation proportions by asset
  plt.figure(figsize=(10, 6))
  for asset in assets:
      plt.plot(df_allocations['Risk'], df_allocations[asset], label=asset, marker='o')

  plt.title("Asset Allocation as a Function of Portfolio Risk")
  plt.xlabel("Portfolio Risk (Variance)")
  plt.ylabel("Proportion Invested")
  plt.legend(title="Asset")
  plt.grid(True)
  plt.tight_layout()
  plt.show()

   # NEW: return the numeric results for use by the wrapper / main.py
  return df_results, df_allocations

def run_portfolio_pipeline(
    ipopt_executable: str,
    tickers,
    start_date,
    end_date,
    min_months_required: int = 6,
):

    # 1) Get monthly returns using  original function
    monthly_returns = fetch_and_analyze_returns(start_date, end_date, tickers)

    if monthly_returns is None or monthly_returns.empty:
        raise RuntimeError(
            "No monthly returns were produced. Check tickers/date range."
        )

    # Optional sanity check on length of the series
    if monthly_returns.shape[0] < min_months_required:
        print(
            f"Warning: only {monthly_returns.shape[0]} monthly observations "
            f"(min recommended = {min_months_required}). Proceeding anyway."
        )

    # 2) Run your optimization model
    df_frontier, df_allocations = run_portfolio_model(
        monthly_returns,
        ipopt_executable=ipopt_executable,
    )

    # 3) Return everything (so main.py can print/inspect)
    return monthly_returns, df_frontier, df_allocations

